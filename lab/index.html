<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#16161a">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='4' fill='%2316161a'/><circle cx='16' cy='16' r='8' fill='none' stroke='%23e8a020' stroke-width='3'/><line x1='16' y1='4' x2='16' y2='12' stroke='%23e8a020' stroke-width='2'/></svg>">
<title>MuJoCo Lab — Level 7 Real Physics</title>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
  }
}
</script>
<link rel="modulepreload" href="https://unpkg.com/three@0.169.0/build/three.module.js" crossorigin>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg:        #16161a;
  --surface:   #1e1e24;
  --raised:    #252530;
  --border:    #2e2e3a;
  --text:      #e8e8e0;
  --text-sec:  #8888a0;
  --text-mute: #555568;
  --accent:    #d4884a;
  --accent-lit:#e8a060;
  --ok:        #60c080;
  --warn:      #e0b040;
  --tcp:       #e05050;
  --radius:    2px;
  --sidebar:   300px;
  --gap:       16px;
  --font-ui:   -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  --font-mono: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
}

html, body {
  height: 100%;
  background: var(--bg);
  color: var(--text);
  font-family: var(--font-ui);
  font-size: 13px;
  line-height: 1.45;
  overflow: hidden;
}

#app {
  display: flex;
  height: 100dvh;
  width: 100vw;
}

#canvas-wrap {
  flex: 1;
  min-width: 0;
  position: relative;
  background: var(--bg);
  overflow: hidden;
}

#canvas-wrap canvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* ── Loading overlay ─────────────────────────────── */
#loading-overlay {
  position: absolute;
  inset: 0;
  background: var(--bg);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 28px;
  z-index: 10;
}

#loading-overlay.hidden { display: none; }

.loading-title {
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--text-mute);
}

.loading-steps {
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-width: 280px;
}

.loading-step {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 12px;
  color: var(--text-mute);
}

.loading-step.active { color: var(--text); }
.loading-step.done { color: var(--ok); }
.loading-step.error { color: var(--tcp); }

.step-indicator {
  width: 8px;
  height: 8px;
  border-radius: var(--radius);
  background: var(--border);
  flex-shrink: 0;
}

.loading-step.active .step-indicator {
  background: var(--accent);
  animation: pulse-indicator 1s ease-in-out infinite;
}

.loading-step.done .step-indicator { background: var(--ok); }
.loading-step.error .step-indicator { background: var(--tcp); }

@keyframes pulse-indicator {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* ── Error banner ────────────────────────────────── */
#error-banner {
  position: absolute;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(30, 20, 20, 0.95);
  border: 1px solid var(--tcp);
  color: var(--tcp);
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.05em;
  padding: 10px 20px;
  max-width: 480px;
  text-align: center;
  z-index: 20;
  display: none;
}

#error-banner.visible { display: block; }

/* ── Sidebar ─────────────────────────────────────── */
#sidebar {
  width: var(--sidebar);
  flex-shrink: 0;
  background: var(--surface);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
  box-shadow: -4px 0 24px rgba(0,0,0,0.5);
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
}

.sidebar-header {
  padding: 14px var(--gap) 12px;
  border-bottom: 1px solid var(--border);
  background: var(--raised);
  flex-shrink: 0;
}

.back-link {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.07em;
  text-transform: uppercase;
  color: var(--text-mute);
  text-decoration: none;
  margin-bottom: 10px;
}

.back-link:hover { color: var(--text-sec); }
.back-link:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

.sidebar-header h1 {
  font-size: 13px;
  font-weight: 700;
  letter-spacing: 0.07em;
  text-transform: uppercase;
  color: var(--text);
  margin-bottom: 2px;
}

.sidebar-header p {
  font-size: 11px;
  color: var(--text-mute);
}

.section {
  padding: var(--gap);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.section-label {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  color: var(--text-mute);
  margin-bottom: 10px;
}

/* ── Buttons ─────────────────────────────────────── */
button {
  font-family: var(--font-ui);
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 0.07em;
  text-transform: uppercase;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  cursor: pointer;
  min-height: 44px;
  padding: 0 14px;
  transition: background 0.12s, border-color 0.12s, color 0.12s;
  background: var(--raised);
  color: var(--text-sec);
}

button:hover {
  background: var(--border);
  color: var(--text);
}

button:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

button.btn-accent {
  background: var(--accent);
  border-color: var(--accent);
  color: #0f0f0f;
}

button.btn-accent:hover {
  background: var(--accent-lit);
  border-color: var(--accent-lit);
}

button.btn-active {
  background: var(--raised);
  border-color: var(--accent);
  color: var(--accent);
}

button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.btn-row {
  display: flex;
  gap: 8px;
}

/* ── File check status ───────────────────────────── */
.file-check-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.file-name {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--text-sec);
}

.file-status {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.07em;
  text-transform: uppercase;
}

.file-status.ok { color: var(--ok); }
.file-status.missing { color: var(--tcp); }
.file-status.unknown { color: var(--text-mute); }

.setup-note {
  font-size: 11px;
  color: var(--text-mute);
  line-height: 1.55;
  margin-bottom: 10px;
}

/* ── API Key input ───────────────────────────────── */
.visually-hidden {
  position: absolute;
  width: 1px; height: 1px;
  padding: 0; margin: -1px;
  overflow: hidden; clip: rect(0,0,0,0);
  white-space: nowrap; border: 0;
}
.api-input {
  width: 100%;
  font-family: var(--font-mono);
  font-size: 11px;
  background: var(--raised);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  color: var(--text);
  padding: 9px 10px;
  margin-bottom: 8px;
  min-height: 44px;
  outline: none;
}

.api-input:focus {
  border-color: var(--accent);
}

.api-input::placeholder {
  color: var(--text-mute);
}

.api-note {
  font-size: 10px;
  color: var(--text-mute);
  line-height: 1.5;
}

/* ── Status display ──────────────────────────────── */
.phase-display {
  font-family: var(--font-mono);
  font-size: 18px;
  font-weight: 700;
  letter-spacing: 0.05em;
  padding: 10px 0 6px;
}

.phase-display.ok { color: var(--ok); }
.phase-display.warn { color: var(--warn); }
.phase-display.idle { color: var(--text-mute); }
.phase-display.error { color: var(--tcp); }

.status-sub {
  font-size: 11px;
  color: var(--text-sec);
  min-height: 16px;
}

/* ── Readout grid ────────────────────────────────── */
.grid-2x2 {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
}

.readout {
  background: var(--raised);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 7px 9px;
}

.readout-label {
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--text-mute);
  margin-bottom: 3px;
}

.readout-val {
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* ── Speed slider ────────────────────────────────── */
.speed-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

.speed-label {
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-mute);
  white-space: nowrap;
}

.speed-val {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--accent);
  white-space: nowrap;
  min-width: 32px;
  text-align: right;
}

input[type=range] {
  -webkit-appearance: none;
  appearance: none;
  flex: 1;
  height: 4px;
  border-radius: 0;
  background: var(--border);
  outline: none;
  cursor: pointer;
}

input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  border-radius: var(--radius);
  background: var(--accent);
  cursor: pointer;
  border: 2px solid var(--raised);
}

input[type=range]:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

/* ── Legend ──────────────────────────────────────── */
.legend-list {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 7px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 9px;
  font-size: 11px;
  color: var(--text-sec);
}

.legend-swatch {
  width: 14px;
  height: 10px;
  border-radius: var(--radius);
  flex-shrink: 0;
}

/* ── Reduced motion ──────────────────────────────── */
@media (prefers-reduced-motion: reduce) {
  button, input[type=range]::-webkit-slider-thumb,
  .loading-step.active .step-indicator {
    animation: none;
    transition: none;
  }
}

/* ── Mobile: portrait — stack canvas above controls ─ */
@media (max-width: 640px) {
  #app { flex-direction: column; }

  #canvas-wrap {
    flex: none;
    height: 55dvh;
    min-height: 220px;
  }

  #sidebar {
    width: 100%;
    flex: 1;
    max-height: 45dvh;
    border-left: none;
    border-top: 1px solid var(--border);
    box-shadow: 0 -4px 24px rgba(0,0,0,0.5);
  }

  .sidebar-header { padding: 10px var(--gap); }
  .section        { padding: 12px var(--gap); }
  .phase-display  { font-size: 15px; }
}

/* ── Mobile: landscape — side-by-side with narrower sidebar ─ */
@media (max-width: 640px) and (orientation: landscape) {
  #app { flex-direction: row; }

  #canvas-wrap {
    flex: 1;
    height: auto;
    min-height: 0;
  }

  #sidebar {
    width: 240px;
    max-height: none;
    border-top: none;
    border-left: 1px solid var(--border);
    box-shadow: -4px 0 24px rgba(0,0,0,0.5);
  }
}
</style>
</head>
<body>
<div id="app">
  <div id="canvas-wrap">
    <canvas id="three-canvas"></canvas>

    <div id="loading-overlay" aria-live="polite" aria-label="Loading progress">
      <div class="loading-title">MuJoCo Lab — Initializing</div>
      <div class="loading-steps">
        <div class="loading-step" id="step-wasm">
          <div class="step-indicator"></div>
          <span>Loading MuJoCo WASM...</span>
        </div>
        <div class="loading-step" id="step-model">
          <div class="step-indicator"></div>
          <span>Fetching robot model...</span>
        </div>
        <div class="loading-step" id="step-vfs">
          <div class="step-indicator"></div>
          <span>Building virtual filesystem...</span>
        </div>
        <div class="loading-step" id="step-physics">
          <div class="step-indicator"></div>
          <span>Initializing physics...</span>
        </div>
        <div class="loading-step" id="step-ready">
          <div class="step-indicator"></div>
          <span>Ready.</span>
        </div>
      </div>
    </div>

    <div id="error-banner" role="alert"></div>
  </div>

  <aside id="sidebar" aria-label="Control panel">

    <!-- Header -->
    <div class="sidebar-header">
      <a href="../index.html" class="back-link">&#8592; Learning Path</a>
      <h1>MuJoCo Lab</h1>
      <p>Level 7 — Real Physics</p>
    </div>

    <!-- Setup -->
    <div class="section">
      <div class="section-label">WASM Files</div>
      <p class="setup-note">Single JS bundle (~10 MB) loaded from jsDelivr CDN. Click below to verify connectivity.</p>
      <div class="file-check-row" style="margin-bottom:12px">
        <span class="file-name">mujoco_wasm.js</span>
        <span class="file-status unknown" id="status-js">—</span>
      </div>
      <button id="btn-check" style="width:100%">Check Files</button>
    </div>

    <!-- Gemini API Key -->
    <div class="section">
      <div class="section-label">GEMINI API KEY</div>
      <form onsubmit="return false">
        <input type="text" autocomplete="username" class="visually-hidden" aria-hidden="true" tabindex="-1">
        <input
          type="password"
          id="api-key-input"
          class="api-input"
          placeholder="AIza..."
          autocomplete="new-password"
          spellcheck="false"
          aria-label="Gemini API key"
        >
      </form>
      <p class="api-note">Saved to localStorage. Never sent anywhere except Google.</p>
    </div>

    <!-- Status -->
    <div class="section">
      <div class="section-label">STATUS</div>
      <div class="phase-display idle" id="phase-display">IDLE</div>
      <div class="status-sub" id="status-sub" aria-live="polite"></div>
    </div>

    <!-- End-effector readouts -->
    <div class="section">
      <div class="section-label">END-EFFECTOR</div>
      <div class="grid-2x2">
        <div class="readout">
          <div class="readout-label">X (m)</div>
          <div class="readout-val" id="ee-x">—</div>
        </div>
        <div class="readout">
          <div class="readout-label">Y (m)</div>
          <div class="readout-val" id="ee-y">—</div>
        </div>
        <div class="readout">
          <div class="readout-label">Z (m)</div>
          <div class="readout-val" id="ee-z">—</div>
        </div>
        <div class="readout">
          <div class="readout-label">Gripper</div>
          <div class="readout-val" id="ee-grip">—</div>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div class="section">
      <div class="section-label">CONTROLS</div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button id="btn-scan" class="btn-accent" disabled>Scan &amp; Pick</button>
        <div class="btn-row">
          <button id="btn-auto" style="flex:1" disabled>Auto Demo</button>
          <button id="btn-reset" style="flex:1" disabled>Reset Scene</button>
        </div>
      </div>
      <div class="speed-row">
        <span class="speed-label">Speed</span>
        <input type="range" id="speed-slider" min="0.25" max="2" step="0.25" value="1" aria-label="Simulation speed">
        <span class="speed-val" id="speed-val">1×</span>
      </div>
    </div>

    <!-- Legend -->
    <div class="section">
      <div class="section-label">LEGEND</div>
      <ul class="legend-list">
        <li class="legend-item">
          <div class="legend-swatch" style="background:#d4884a"></div>
          <span>Robot links</span>
        </li>
        <li class="legend-item">
          <div class="legend-swatch" style="background:#f0a060;border-radius:50%"></div>
          <span>Joints</span>
        </li>
        <li class="legend-item">
          <div class="legend-swatch" style="background:#e05050"></div>
          <span>TCP / Gripper</span>
        </li>
        <li class="legend-item">
          <div class="legend-swatch" style="background:#60c080"></div>
          <span>Target marker</span>
        </li>
        <li class="legend-item">
          <div class="legend-swatch" style="background:#cc2525"></div>
          <span>Cubes</span>
        </li>
        <li class="legend-item">
          <div class="legend-swatch" style="background:#4a4a66"></div>
          <span>Tray (drop zone)</span>
        </li>
      </ul>
    </div>

  </aside>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ── DOM refs ──────────────────────────────────────────────────────────
const canvasEl        = document.getElementById('three-canvas');
const loadingOverlay  = document.getElementById('loading-overlay');
const errorBanner     = document.getElementById('error-banner');
const phaseDisplay    = document.getElementById('phase-display');
const statusSub       = document.getElementById('status-sub');
const eeX             = document.getElementById('ee-x');
const eeY             = document.getElementById('ee-y');
const eeZ             = document.getElementById('ee-z');
const eeGrip          = document.getElementById('ee-grip');
const btnScan         = document.getElementById('btn-scan');
const btnAuto         = document.getElementById('btn-auto');
const btnReset        = document.getElementById('btn-reset');
const btnCheck        = document.getElementById('btn-check');
const speedSlider     = document.getElementById('speed-slider');
const speedVal        = document.getElementById('speed-val');
const apiKeyInput     = document.getElementById('api-key-input');

// ── Loading step helpers ──────────────────────────────────────────────
function stepActive(id) {
  const el = document.getElementById(id);
  el.className = 'loading-step active';
}
function stepDone(id) {
  const el = document.getElementById(id);
  el.className = 'loading-step done';
}
function stepError(id, msg) {
  const el = document.getElementById(id);
  el.className = 'loading-step error';
  el.querySelector('span').textContent = msg;
}

// ── Error display ─────────────────────────────────────────────────────
function showError(msg) {
  errorBanner.textContent = msg;
  errorBanner.classList.add('visible');
}

// ── Phase / status helpers ────────────────────────────────────────────
const PHASE_COLORS = {
  IDLE: 'idle', LOADING: 'warn', SCANNING: 'warn',
  APPROACHING_ABOVE: 'warn', APPROACHING: 'warn',
  GRASPING: 'warn', LIFTING: 'ok', TRANSPORTING: 'ok',
  PLACING: 'ok', RETRACTING: 'ok', DONE: 'ok', ERROR: 'error'
};

function setPhase(phase, sub = '') {
  phaseDisplay.textContent = phase;
  phaseDisplay.className = 'phase-display ' + (PHASE_COLORS[phase] || 'idle');
  statusSub.textContent = sub;
}

// ── MuJoCo WASM loader ────────────────────────────────────────────────
// mujoco-js embeds the WASM binary inside the JS bundle (10.5MB single file)
const MUJOCO_JS_CDN = 'https://cdn.jsdelivr.net/npm/mujoco-js@0.0.7/dist/mujoco_wasm.js';

async function loadMuJoCo() {
  const jsRes = await fetch(MUJOCO_JS_CDN);
  if (!jsRes.ok) throw new Error('Failed to fetch MuJoCo from CDN (status ' + jsRes.status + ')');

  const jsBlob = new Blob([await jsRes.arrayBuffer()], { type: 'application/javascript' });
  const jsUrl = URL.createObjectURL(jsBlob);

  const module = await import(/* @vite-ignore */ jsUrl);
  const loadMujoco = module.default;

  return await loadMujoco();
}

// ── Scene constants ───────────────────────────────────────────────────
const MENAGERIE_BASE = 'https://raw.githubusercontent.com/google-deepmind/mujoco_menagerie/main/franka_emika_panda/';

const CUBE_POSITIONS = [
  { x: -0.3, y: 0, z: 0.44 },
  { x: -0.1, y: 0, z: 0.44 },
  { x:  0.1, y: 0, z: 0.44 },
  { x:  0.3, y: 0, z: 0.44 },
];

const TRAY_POS = { x: 0.5, y: 0, z: 0.44 };
const HOME_POS = [0, -0.5, 0, -1.5, 0, 1.0, 0.785];

// Franka Panda hard joint limits (rad) — must be enforced in IK or arm spasms
const PANDA_LIMITS = [
  [-2.8973,  2.8973], // joint 1
  [-1.7628,  1.7628], // joint 2
  [-2.8973,  2.8973], // joint 3
  [-3.0718, -0.0698], // joint 4 — always negative
  [-2.8973,  2.8973], // joint 5
  [-0.0175,  3.7525], // joint 6
  [-2.8973,  2.8973], // joint 7
];

// ── Three.js setup ────────────────────────────────────────────────────
const renderer = new THREE.WebGLRenderer({
  canvas: canvasEl,
  antialias: true,
  preserveDrawingBuffer: true
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x16161a);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x16161a);

const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 50);
camera.position.set(0, 1.2, 1.8);
camera.lookAt(0, 0.5, 0);

const controls = new OrbitControls(camera, canvasEl);
controls.target.set(0, 0.5, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.update();

// Top-down camera for Gemini scan — positioned in Three.js Y-up space
// Cubes are at MuJoCo Z=0.44 → Three.js Y=0.44 after mujocoRoot rotation
const topDownCamera = new THREE.OrthographicCamera(-0.6, 0.6, 0.4, -0.4, 0.01, 10);
topDownCamera.position.set(0, 2.5, 0);
topDownCamera.up.set(0, 0, -1); // MuJoCo +Y (forward) as image-up
topDownCamera.lookAt(0, 0.44, 0);

// Lighting
const ambient = new THREE.AmbientLight(0x404040, 0.6);
scene.add(ambient);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(2, 4, 3);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(2048, 2048);
dirLight.shadow.camera.near = 0.1;
dirLight.shadow.camera.far = 20;
dirLight.shadow.camera.left = -2;
dirLight.shadow.camera.right = 2;
dirLight.shadow.camera.top = 2;
dirLight.shadow.camera.bottom = -2;
scene.add(dirLight);

// Ground plane
const groundGeo = new THREE.PlaneGeometry(1.5, 1.5);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x252530 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// MuJoCo scene root: rotate -90° around X to convert Z-up (MuJoCo) → Y-up (Three.js)
// All body groups and dynamic objects live here so positions stay in MuJoCo coordinates
const mujocoRoot = new THREE.Group();
mujocoRoot.rotation.x = -Math.PI / 2;
scene.add(mujocoRoot);

// Target marker lives inside mujocoRoot so position.set uses MuJoCo Z-up coords directly
const targetMarker = new THREE.Mesh(
  new THREE.SphereGeometry(0.015, 8, 8),
  new THREE.MeshStandardMaterial({ color: 0x60c080, emissive: 0x206040 })
);
targetMarker.visible = false;
mujocoRoot.add(targetMarker);

// Resize handler
function onResize() {
  const wrap = canvasEl.parentElement;
  const w = wrap.clientWidth;
  const h = wrap.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize);
screen.orientation?.addEventListener('change', onResize);
onResize();

// ── Robot model building ──────────────────────────────────────────────
function buildPatchedXML(originalXML) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(originalXML, 'text/xml');

  const worldbody = doc.querySelector('worldbody');
  if (!worldbody) throw new Error('No <worldbody> in scene.xml');

  // Add cubes
  CUBE_POSITIONS.forEach((pos, i) => {
    const body = doc.createElement('body');
    body.setAttribute('name', `cube_${i}`);
    body.setAttribute('pos', `${pos.x} ${pos.y} ${pos.z}`);
    const geom = doc.createElement('geom');
    geom.setAttribute('name', `cube_geom_${i}`);
    geom.setAttribute('type', 'box');
    geom.setAttribute('size', '0.025 0.025 0.025');
    geom.setAttribute('rgba', '0.8 0.15 0.15 1');
    geom.setAttribute('mass', '0.1');
    const joint = doc.createElement('freejoint');
    joint.setAttribute('name', `cube_joint_${i}`);
    body.appendChild(joint);
    body.appendChild(geom);
    worldbody.appendChild(body);
  });

  // Add tray
  const trayBody = doc.createElement('body');
  trayBody.setAttribute('name', 'tray');
  trayBody.setAttribute('pos', `${TRAY_POS.x} ${TRAY_POS.y} ${TRAY_POS.z}`);
  const trayGeom = doc.createElement('geom');
  trayGeom.setAttribute('name', 'tray_geom');
  trayGeom.setAttribute('type', 'box');
  trayGeom.setAttribute('size', '0.12 0.08 0.005');
  trayGeom.setAttribute('rgba', '0.3 0.3 0.4 1');
  trayBody.appendChild(trayGeom);
  worldbody.appendChild(trayBody);

  const serializer = new XMLSerializer();
  return serializer.serializeToString(doc);
}

async function loadRobotModel(mujoco) {
  try { mujoco.FS.mkdir('/working'); } catch (_) {}
  try { mujoco.FS.mkdir('/working/assets'); } catch (_) {}

  const binaryExts = new Set(['stl', 'png', 'jpg', 'jpeg', 'obj']);

  async function fetchAndWrite(url, vfsPath) {
    const res = await fetch(url);
    if (!res.ok) return;
    const ext = vfsPath.split('.').pop().toLowerCase();
    if (binaryExts.has(ext)) {
      mujoco.FS.writeFile(vfsPath, new Uint8Array(await res.arrayBuffer()));
    } else {
      mujoco.FS.writeFile(vfsPath, await res.text());
    }
  }

  // Fetch scene.xml
  const sceneRes = await fetch(MENAGERIE_BASE + 'scene.xml');
  if (!sceneRes.ok) throw new Error('Failed to fetch scene.xml from Menagerie');
  const sceneText = await sceneRes.text();

  // Process XML includes (e.g. panda.xml)
  const includeFiles = [...sceneText.matchAll(/file="([^"]+\.xml)"/g)].map(m => m[1]);
  for (const xmlFile of includeFiles) {
    const xmlUrl = MENAGERIE_BASE + xmlFile;
    const xmlRes = await fetch(xmlUrl);
    if (!xmlRes.ok) continue;
    let xmlText = await xmlRes.text();

    // Inject TCP site into hand body so IK has a target site to track
    if (xmlFile === 'panda.xml') {
      xmlText = xmlText.replace(
        /(<body name="hand"[^>]*>)/,
        '$1<site name="tcp" pos="0 0 0.105" size="0.01" group="1"/>'
      );
    }

    mujoco.FS.writeFile('/working/' + xmlFile, xmlText);

    // Extract meshdir from <compiler meshdir="..."> — defaults to empty string
    const meshdirMatch = xmlText.match(/meshdir="([^"]+)"/);
    const meshdir = meshdirMatch ? meshdirMatch[1] : '';

    // Fetch all mesh/texture assets referenced in this XML
    const assetFiles = [...xmlText.matchAll(/file="([^"]+)"/g)].map(m => m[1])
      .filter(f => !f.endsWith('.xml'));

    for (const assetFile of assetFiles) {
      // Asset file paths in XML are relative to the XML (no meshdir prefix in them),
      // but MuJoCo resolves them through meshdir at runtime.
      // Actual location on server: MENAGERIE_BASE/meshdir/assetFile
      const serverPath = meshdir ? `${meshdir}/${assetFile}` : assetFile;
      const assetUrl = MENAGERIE_BASE + serverPath;
      // VFS path: /working/meshdir/assetFile (mirrors the on-disk structure)
      const vfsPath = meshdir ? `/working/${meshdir}/${assetFile}` : `/working/${assetFile}`;
      try { await fetchAndWrite(assetUrl, vfsPath); } catch (_) {}
    }
  }

  // Patch scene XML and write to VFS
  const patchedXML = buildPatchedXML(sceneText);
  mujoco.FS.writeFile('/working/scene.xml', patchedXML);

  const model = mujoco.MjModel.loadFromXML('/working/scene.xml');
  const data = new mujoco.MjData(model);
  return { model, data };
}

// ── Body geometry sync ────────────────────────────────────────────────
function buildBodyGroups(mujoco, model) {
  const groups = [];

  // Materials
  const linkMat = new THREE.MeshStandardMaterial({ color: 0xd0d0dc, metalness: 0.5, roughness: 0.3 });
  const cubeMat = new THREE.MeshStandardMaterial({ color: 0xcc2525, roughness: 0.6 });
  const trayMat = new THREE.MeshStandardMaterial({ color: 0x4a4a66, roughness: 0.8 });

  for (let b = 0; b < model.nbody; b++) {
    const g = new THREE.Group();
    mujocoRoot.add(g); // lives inside mujocoRoot (MuJoCo Z-up coords)
    groups.push(g);
  }

  const GEOM = { PLANE: 0, HFIELD: 1, SPHERE: 2, CAPSULE: 3, ELLIPSOID: 4, CYLINDER: 5, BOX: 6, MESH: 7 };

  for (let gi = 0; gi < model.ngeom; gi++) {
    // Skip collision-only geoms (group 3 in Menagerie Franka model)
    // Visual meshes use group 2; collision primitives use group 3
    if (model.geom_group[gi] === 3) continue;

    const bodyId = model.geom_bodyid[gi];
    const type   = model.geom_type[gi];
    const size   = model.geom_size.subarray(gi * 3, gi * 3 + 3);
    const gpos   = model.geom_pos.subarray(gi * 3, gi * 3 + 3);
    const gquat  = model.geom_quat.subarray(gi * 4, gi * 4 + 4);
    const rgba   = model.geom_rgba.subarray(gi * 4, gi * 4 + 4);

    let geo = null;
    let mat = null;

    const r = rgba[0], g2 = rgba[1], b2 = rgba[2];
    if      (r > 0.6 && g2 < 0.3 && b2 < 0.3) mat = cubeMat;
    else if (b2 > 0.3 && r < 0.4 && g2 < 0.4) mat = trayMat;
    else mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(r, g2, b2), metalness: 0.25, roughness: 0.55 });

    if (type === GEOM.MESH) {
      const meshId = model.geom_dataid[gi];
      if (meshId >= 0) {
        const va = model.mesh_vertadr[meshId];
        const vn = model.mesh_vertnum[meshId];
        const fa = model.mesh_faceadr[meshId];
        const fn = model.mesh_facenum[meshId];
        // Copy vertex/face data out of WASM heap into fresh typed arrays
        const verts = new Float32Array(model.mesh_vert.subarray(va * 3, (va + vn) * 3));
        const faces = new Uint32Array(model.mesh_face.subarray(fa * 3, (fa + fn) * 3));
        geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        geo.setIndex(new THREE.BufferAttribute(faces, 1));
        geo.computeVertexNormals();
        mat = linkMat;
      } else {
        continue;
      }
    } else if (type === GEOM.BOX) {
      geo = new THREE.BoxGeometry(size[0] * 2, size[1] * 2, size[2] * 2);
    } else if (type === GEOM.SPHERE) {
      geo = new THREE.SphereGeometry(size[0], 16, 12);
    } else if (type === GEOM.CAPSULE) {
      geo = new THREE.CapsuleGeometry(size[0], size[1] * 2, 4, 8);
    } else if (type === GEOM.CYLINDER) {
      geo = new THREE.CylinderGeometry(size[0], size[0], size[1] * 2, 16);
    } else {
      continue; // skip PLANE and others — manual ground plane handles the floor
    }

    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    // geom_pos/quat are body-local in MuJoCo Z-up space — correct within mujocoRoot hierarchy
    mesh.position.set(gpos[0], gpos[1], gpos[2]);
    mesh.quaternion.set(gquat[1], gquat[2], gquat[3], gquat[0]); // MuJoCo [w,x,y,z] → Three [x,y,z,w]
    groups[bodyId].add(mesh);
  }

  return groups;
}

// syncBodies writes MuJoCo world-frame positions/quaternions into body groups.
// mujocoRoot's -PI/2 X rotation converts the entire subtree from Z-up to Y-up.
function syncBodies(model, data, bodyGroups) {
  for (let b = 0; b < model.nbody; b++) {
    const pos  = data.xpos.subarray(b * 3, b * 3 + 3);
    const quat = data.xquat.subarray(b * 4, b * 4 + 4);
    bodyGroups[b].position.set(pos[0], pos[1], pos[2]);
    bodyGroups[b].quaternion.set(quat[1], quat[2], quat[3], quat[0]);
  }
}

// ── IK solver ──────────────────────────────────────────────────────────
// One numerical-Jacobian gradient step per frame.
// DLS per-column damping prevents wild steps near singularities.
// Joint limits clamp prevents physically impossible poses.
// Cost: 1 base + 7 perturbed mj_forward calls = 8 total (~2 ms).
const _ikDqs     = new Float64Array(7);
const MAX_DQ     = 0.035;  // ~2 deg/frame — smooth arcs at 60 fps
const IK_LAMBDA2 = 0.0025; // DLS λ² = 0.05² — damps near-singular columns
const ORI_WEIGHT = 0.5;    // weight of orientation vs position in the 5D error (0 = position-only)

function solveIK(mujoco, model, data, targetPos, siteId) {
  const sp   = data.site_xpos;
  const sm   = data.site_xmat; // row-major 3×3 rotation matrices for sites
  const eps  = 1e-4;
  const base = siteId * 9;

  mujoco.mj_forward(model, data);
  const x0 = sp[siteId*3], y0 = sp[siteId*3+1], z0 = sp[siteId*3+2];
  const ex = targetPos[0]-x0, ey = targetPos[1]-y0, ez = targetPos[2]-z0;
  const dist = Math.hypot(ex, ey, ez);

  // Zero arm qvel so accumulated velocity doesn't drift past target
  for (let j = 0; j < 7; j++) data.qvel[j] = 0;

  // Orientation error: align TCP Z-axis with world -Z (gripper pointing straight down).
  // xmat column 2 = TCP Z in world = [mat[2], mat[5], mat[8]] (row-major).
  // e_ori = current_z × desired_z  where desired = [0,0,-1]
  //       = [czx,czy,czz] × [0,0,-1] = [-czy, czx, 0]
  // Zero when already aligned; grows with angular deviation.
  const czx0 = sm ? sm[base+2] : 0;
  const czy0 = sm ? sm[base+5] : 0;
  const oex0 = -czy0 * ORI_WEIGHT;
  const oey0 =  czx0 * ORI_WEIGHT;

  if (dist < 5e-4 && Math.hypot(oex0, oey0) < 1e-3) return;

  // Scale position step down near target to prevent overshoot/oscillation.
  // Orientation steps run at full rate so the gripper keeps settling.
  const stepScale = Math.min(1.0, dist / 0.05);

  for (let j = 0; j < 7; j++) {
    const q0 = data.qpos[j];
    data.qpos[j] = q0 + eps;
    mujoco.mj_forward(model, data);

    // Position Jacobian column j
    const jx = (sp[siteId*3]  -x0)/eps;
    const jy = (sp[siteId*3+1]-y0)/eps;
    const jz = (sp[siteId*3+2]-z0)/eps;

    // Orientation Jacobian column j: finite-difference of e_ori
    const jox = sm ? (czy0 - sm[base+5]) / eps * ORI_WEIGHT : 0;
    const joy = sm ? (sm[base+2] - czx0) / eps * ORI_WEIGHT : 0;

    data.qpos[j] = q0;

    // DLS combining 5D position+orientation error
    const jdot_e = jx*ex + jy*ey + jz*ez + jox*oex0 + joy*oey0;
    const jnorm2 = jx*jx + jy*jy + jz*jz + jox*jox + joy*joy + IK_LAMBDA2;
    const raw = jdot_e / jnorm2;
    _ikDqs[j] = Math.sign(raw) * Math.min(Math.abs(raw), MAX_DQ * stepScale);
  }

  for (let j = 0; j < 7; j++) {
    const [lo, hi] = PANDA_LIMITS[j];
    data.qpos[j] = Math.max(lo, Math.min(hi, data.qpos[j] + _ikDqs[j]));
    data.ctrl[j] = data.qpos[j];
  }
}

// ── Smooth TCP trajectory ───────────────────────────────────────────────
// Instead of snapping the IK target on every phase transition, advance a
// sub-target toward the final waypoint at a fixed Cartesian speed.
// This eliminates the direction-change jerk between phases.
const TCP_SPEED  = 0.004; // m/frame ≈ 0.24 m/s — natural human arm pace
let _smoothTarget = null;

function resetSmoothTarget() { _smoothTarget = null; }

function moveTCP(finalPos) {
  simState.targetPos = finalPos;
  if (siteId < 0) return;

  if (!_smoothTarget) {
    // Bootstrap from current TCP position so arm doesn't jump
    const tcp = getTCPPos(data, siteId);
    _smoothTarget = tcp ? [...tcp] : [...finalPos];
  }

  const dx = finalPos[0]-_smoothTarget[0];
  const dy = finalPos[1]-_smoothTarget[1];
  const dz = finalPos[2]-_smoothTarget[2];
  const dist = Math.hypot(dx, dy, dz);
  if (dist <= TCP_SPEED) {
    _smoothTarget[0] = finalPos[0]; _smoothTarget[1] = finalPos[1]; _smoothTarget[2] = finalPos[2];
  } else {
    const s = TCP_SPEED / dist;
    _smoothTarget[0] += dx*s; _smoothTarget[1] += dy*s; _smoothTarget[2] += dz*s;
  }

  targetMarker.position.set(_smoothTarget[0], _smoothTarget[1], _smoothTarget[2]);
  solveIK(mujoco, model, data, _smoothTarget, siteId);
}

// ── State machine ─────────────────────────────────────────────────────
const TIMESTEP = 1 / 500;
const STEPS_PER_FRAME = 5;

let mujoco = null;
let model = null;
let data = null;
let bodyGroups = [];
let siteId = -1;
let gripperJointIds = [];
let gripperActuatorIds = [];
let cubeJointIds = [];

let simState = {
  phase: 'IDLE',
  cubeQueue: [],
  currentCube: null,
  targetPos: null,
  gripperOpen: true,
  autoDemo: false,
  speed: 1.0,
  frameId: null,
  initialQpos: null,
  cubePosBackup: [],
};

function findSiteId(model, name) {
  for (let i = 0; i < model.nsite; i++) {
    // Decode site name from MuJoCo name array
    const start = model.name_siteadr[i];
    let end = start;
    while (model.names[end] !== 0) end++;
    const siteName = String.fromCharCode(...model.names.subarray(start, end));
    if (siteName === name) return i;
  }
  return -1;
}

function findJointId(model, name) {
  for (let i = 0; i < model.njnt; i++) {
    const start = model.name_jntadr[i];
    let end = start;
    while (model.names[end] !== 0) end++;
    const jntName = String.fromCharCode(...model.names.subarray(start, end));
    if (jntName === name) return i;
  }
  return -1;
}

function getTCPPos(data, siteId) {
  if (siteId < 0) return null;
  return [...data.site_xpos.subarray(siteId * 3, siteId * 3 + 3)];
}

function setGripper(open) {
  simState.gripperOpen = open;
  const val = open ? 0.04 : 0.0;
  for (const id of gripperJointIds) {
    data.qpos[model.jnt_qposadr[id]] = val;
  }
  for (const aid of gripperActuatorIds) {
    data.ctrl[aid] = val;
  }
}

function phaseDist(targetPos) {
  const tcp = getTCPPos(data, siteId);
  if (!tcp || !targetPos) return Infinity;
  return Math.hypot(tcp[0] - targetPos[0], tcp[1] - targetPos[1], tcp[2] - targetPos[2]);
}

// Teleport the grasped cube to sit just below the TCP.
// Called every tick while gripper is closed so the cube follows the arm visually.
function attachCubeToTCP() {
  const idx = simState.currentCube;
  if (idx === null) return;
  const jid = cubeJointIds[idx];
  if (jid < 0) return;
  const tcp = getTCPPos(data, siteId);
  if (!tcp) return;
  const qadr = model.jnt_qposadr[jid];
  data.qpos[qadr]     = tcp[0];
  data.qpos[qadr + 1] = tcp[1];
  data.qpos[qadr + 2] = tcp[2] - 0.05; // cube centre sits ~5 cm below TCP
  // Identity quaternion
  data.qpos[qadr + 3] = 1; data.qpos[qadr + 4] = 0;
  data.qpos[qadr + 5] = 0; data.qpos[qadr + 6] = 0;
  // Zero velocity so cube doesn't drift
  const vadr = model.jnt_dofadr[jid];
  for (let k = 0; k < 6; k++) data.qvel[vadr + k] = 0;
}

// Cube positions tracked in JS (since MuJoCo freejoint cubes move)
let cubePositions = CUBE_POSITIONS.map(p => ({ x: p.x, y: p.y, z: p.z }));

function getCubePos(idx) {
  return cubePositions[idx];
}

// Phase transition distance threshold (2.5 cm — achievable with kinematic IK + DLS)
const PHASE_DIST_THRESH = 0.025;

function tickStateMachine(dt) {
  const { phase } = simState;

  if (phase === 'IDLE') {
    if (simState.autoDemo && simState.cubeQueue.length === 0) {
      simState.cubeQueue = [0, 1, 2, 3];
    }
    if (simState.cubeQueue.length > 0) {
      simState.currentCube = simState.cubeQueue.shift();
      transitionTo('APPROACHING_ABOVE');
    }
    return;
  }

  if (phase === 'APPROACHING_ABOVE') {
    const cp = getCubePos(simState.currentCube);
    const above = [cp.x, cp.y, cp.z + 0.18];
    targetMarker.visible = true;
    moveTCP(above); // also sets targetMarker.position via smooth target
    if (phaseDist(above) < PHASE_DIST_THRESH) transitionTo('APPROACHING');
    return;
  }

  if (phase === 'APPROACHING') {
    const cp = getCubePos(simState.currentCube);
    moveTCP([cp.x, cp.y, cp.z + 0.05]);
    if (phaseDist([cp.x, cp.y, cp.z + 0.05]) < PHASE_DIST_THRESH) transitionTo('GRASPING');
    return;
  }

  if (phase === 'GRASPING') {
    setGripper(false);
    attachCubeToTCP();
    simState._graspTimer = (simState._graspTimer || 0) + dt;
    if (simState._graspTimer > 0.4) { // 0.4 s real time
      simState._graspTimer = 0;
      transitionTo('LIFTING');
    }
    return;
  }

  if (phase === 'LIFTING') {
    attachCubeToTCP();
    const liftPos = [CUBE_POSITIONS[simState.currentCube].x,
                     CUBE_POSITIONS[simState.currentCube].y,
                     CUBE_POSITIONS[simState.currentCube].z + 0.22];
    moveTCP(liftPos);
    if (phaseDist(liftPos) < PHASE_DIST_THRESH) transitionTo('TRANSPORTING');
    return;
  }

  if (phase === 'TRANSPORTING') {
    attachCubeToTCP();
    moveTCP([TRAY_POS.x, TRAY_POS.y, TRAY_POS.z + 0.22]);
    if (phaseDist([TRAY_POS.x, TRAY_POS.y, TRAY_POS.z + 0.22]) < PHASE_DIST_THRESH) transitionTo('PLACING');
    return;
  }

  if (phase === 'PLACING') {
    const placePos = [TRAY_POS.x, TRAY_POS.y, TRAY_POS.z + 0.08];
    moveTCP(placePos);
    if (phaseDist(placePos) < PHASE_DIST_THRESH) {
      // Snap cube to tray centre and release gripper
      const jid = cubeJointIds[simState.currentCube];
      if (jid >= 0) {
        const qa = model.jnt_qposadr[jid];
        data.qpos[qa]   = TRAY_POS.x; data.qpos[qa+1] = TRAY_POS.y;
        data.qpos[qa+2] = TRAY_POS.z + 0.03;
        data.qpos[qa+3] = 1; data.qpos[qa+4] = 0; data.qpos[qa+5] = 0; data.qpos[qa+6] = 0;
      }
      setGripper(true);
      simState._placeTimer = (simState._placeTimer || 0) + dt;
      if (simState._placeTimer > 0.3) { // 0.3 s real time
        simState._placeTimer = 0;
        transitionTo('RETRACTING');
      }
    } else {
      attachCubeToTCP();
    }
    return;
  }

  if (phase === 'RETRACTING') {
    targetMarker.visible = false;
    moveTCP([0, -0.3, 0.7]);
    if (phaseDist([0, -0.3, 0.7]) < 0.04) {
      transitionTo(simState.cubeQueue.length > 0 ? 'IDLE' : 'DONE');
    }
    return;
  }

  if (phase === 'DONE') {
    targetMarker.visible = false;
    if (simState.autoDemo) {
      cubePositions = CUBE_POSITIONS.map(p => ({ x: p.x, y: p.y, z: p.z }));
      transitionTo('IDLE');
    }
    return;
  }
}

const PHASE_LABELS = {
  APPROACHING_ABOVE: 'APPROACHING',
};

function transitionTo(phase) {
  simState.phase = phase;
  setPhase(PHASE_LABELS[phase] || phase,
    phase === 'GRASPING' ? 'Closing gripper...' :
    phase === 'LIFTING'  ? `Lifting cube ${simState.currentCube}` :
    phase === 'TRANSPORTING' ? 'Moving to tray...' :
    phase === 'PLACING'  ? 'Placing in tray...' :
    phase === 'RETRACTING' ? 'Retracting...' :
    phase === 'DONE'     ? 'Pick complete.' : '');
}

// ── Readout update ────────────────────────────────────────────────────
const dbgEl = (() => {
  const d = document.createElement('pre');
  d.id = 'dbg';
  Object.assign(d.style, {
    position:'fixed', bottom:'8px', left:'8px', margin:'0',
    background:'rgba(0,0,0,0.7)', color:'#7fff7f',
    font:'11px/1.5 monospace', padding:'6px 8px',
    borderRadius:'3px', pointerEvents:'none', zIndex:'999',
    display: 'none', // hidden by default; toggle with D key
  });
  document.body.appendChild(d);
  return d;
})();

window.addEventListener('keydown', e => {
  if (e.key === 'd' || e.key === 'D') {
    dbgEl.style.display = dbgEl.style.display === 'none' ? 'block' : 'none';
  }
});

function updateReadouts() {
  const tcp = getTCPPos(data, siteId);
  if (tcp) {
    eeX.textContent = tcp[0].toFixed(3);
    eeY.textContent = tcp[1].toFixed(3);
    eeZ.textContent = tcp[2].toFixed(3);

    if (dbgEl.style.display !== 'none') {
      const tgt = simState.targetPos;
      const dist = tgt ? Math.hypot(tcp[0]-tgt[0], tcp[1]-tgt[1], tcp[2]-tgt[2]) : '-';
      dbgEl.textContent =
        `phase  : ${simState.phase}\n` +
        `tcp    : ${tcp.map(v=>v.toFixed(3)).join('  ')}\n` +
        `target : ${tgt ? tgt.map(v=>v.toFixed(3)).join('  ') : 'none'}\n` +
        `dist   : ${typeof dist === 'number' ? dist.toFixed(4) : dist}\n` +
        `cube   : ${simState.currentCube ?? '-'}\n` +
        `gripper: ${simState.gripperOpen ? 'open' : 'closed'}`;
    }
  }
  eeGrip.textContent = simState.gripperOpen ? 'OPEN' : 'CLOSED';
}

// ── Main animation loop ───────────────────────────────────────────────
let loopRunning = false;
let lastFrameTime = null;

function startLoop() {
  if (loopRunning) return;
  loopRunning = true;
  lastFrameTime = null;
  loop();
}

function loop() {
  if (!loopRunning) return;
  simState.frameId = requestAnimationFrame(loop);

  const now = performance.now();
  if (lastFrameTime === null) { lastFrameTime = now; }
  const dt = Math.min((now - lastFrameTime) / 1000, 0.05); // cap at 50ms
  lastFrameTime = now;

  // State machine + IK run once per frame (IK is expensive: nArm mj_forwards per iteration)
  tickStateMachine(dt);

  // Physics steps run independently — arm held by ctrl set during IK
  const steps = Math.round(STEPS_PER_FRAME * simState.speed);
  for (let s = 0; s < steps; s++) {
    mujoco.mj_step(model, data);
  }

  syncBodies(model, data, bodyGroups);
  updateReadouts();

  controls.update();
  renderer.render(scene, camera);
}

// ── Gemini vision ─────────────────────────────────────────────────────
async function scanWithGemini(apiKey) {
  // Move to top-down view, render, capture
  const prevSize = renderer.getSize(new THREE.Vector2());

  // Render top-down snapshot at fixed size
  renderer.setSize(512, 512);
  renderer.render(scene, topDownCamera);
  const imageBase64 = canvasEl.toDataURL('image/png').split(',')[1];

  // Restore renderer size
  renderer.setSize(prevSize.x, prevSize.y);
  camera.aspect = prevSize.x / prevSize.y;
  camera.updateProjectionMatrix();

  const prompt = `This is a top-down view of a robotic workspace.
Identify all red cubes visible in the image.
The workspace spans approximately -0.4m to +0.4m on the horizontal axis and -0.3m to +0.3m on the vertical axis, with (0,0) at center.
Return ONLY valid JSON, no markdown: {"cubes": [{"x": number, "y": number, "label": "A"|"B"|"C"|"D"}]}
x increases to the right, y increases upward.`;

  const res = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [
          { text: prompt },
          { inline_data: { mime_type: 'image/png', data: imageBase64 } }
        ]}]
      })
    }
  );

  if (!res.ok) {
    const errText = await res.text();
    throw new Error(`Gemini API error ${res.status}: ${errText.slice(0, 120)}`);
  }

  const respData = await res.json();
  if (!respData.candidates?.length) throw new Error('Gemini returned no candidates');
  const text = respData.candidates[0].content.parts[0].text;
  const json = text.replace(/```json\n?|\n?```/g, '').trim();
  return JSON.parse(json);
}

// ── Persist API key ───────────────────────────────────────────────────
const STORAGE_KEY = 'robosimu_gemini_key';
const isValidKey = v => /^AIza[0-9A-Za-z_-]{35}$/.test(v.trim());
const savedKey = localStorage.getItem(STORAGE_KEY);
if (savedKey && isValidKey(savedKey)) apiKeyInput.value = savedKey;
else localStorage.removeItem(STORAGE_KEY);
apiKeyInput.addEventListener('input', () => {
  const v = apiKeyInput.value.trim();
  if (isValidKey(v)) localStorage.setItem(STORAGE_KEY, v);
  else localStorage.removeItem(STORAGE_KEY);
});

// ── Controls ──────────────────────────────────────────────────────────
btnCheck.addEventListener('click', async () => {
  const jsEl = document.getElementById('status-js');
  jsEl.textContent = '...';
  jsEl.className   = 'file-status unknown';

  const jsRes = await fetch('https://cdn.jsdelivr.net/npm/mujoco-js@0.0.7/dist/mujoco_wasm.js', { method: 'HEAD' }).catch(() => ({ ok: false }));
  jsEl.textContent = jsRes.ok ? 'OK' : 'MISSING';
  jsEl.className   = 'file-status ' + (jsRes.ok ? 'ok' : 'missing');
});

btnScan.addEventListener('click', async () => {
  const apiKey = apiKeyInput.value.trim();
  if (!apiKey) {
    setPhase('ERROR', 'Enter Gemini API key first.');
    return;
  }

  btnScan.disabled = true;
  setPhase('SCANNING', 'Capturing scene...');

  try {
    const result = await scanWithGemini(apiKey);
    const count = result.cubes?.length ?? 0;
    setPhase('SCANNING', `Found ${count} cube${count !== 1 ? 's' : ''}`);

    // Build queue from Gemini-identified positions
    // Map returned cubes to nearest known cube indices
    const queue = [];
    if (result.cubes?.length) {
      for (const cube of result.cubes) {
        let bestIdx = 0;
        let bestDist = Infinity;
        cubePositions.forEach((cp, i) => {
          const d = Math.hypot(cp.x - cube.x, cp.y - cube.y);
          if (d < bestDist) { bestDist = d; bestIdx = i; }
        });
        if (!queue.includes(bestIdx)) queue.push(bestIdx);
      }
    } else {
      queue.push(0, 1, 2, 3);
    }

    simState.cubeQueue = queue;
    simState.phase = 'IDLE';
    setPhase('IDLE', `Queued ${queue.length} cubes.`);

  } catch (err) {
    setPhase('ERROR', err.message.slice(0, 80));
    showError('Gemini: ' + err.message);
  } finally {
    btnScan.disabled = false;
  }
});

btnAuto.addEventListener('click', () => {
  simState.autoDemo = !simState.autoDemo;
  btnAuto.classList.toggle('btn-active', simState.autoDemo);
  if (simState.autoDemo) {
    simState.cubeQueue = [0, 1, 2, 3];
    simState.phase = 'IDLE';
    setPhase('IDLE', 'Auto demo running...');
  } else {
    simState.cubeQueue = [];
    simState.phase = 'IDLE';
    setPhase('IDLE', 'Paused.');
  }
});

btnReset.addEventListener('click', () => {
  simState.phase = 'IDLE';
  simState.cubeQueue = [];
  simState.currentCube = null;
  simState.autoDemo = false;
  simState._graspTimer = 0;
  simState._placeTimer = 0;
  btnAuto.classList.remove('btn-active');
  targetMarker.visible = false;
  setGripper(true);
  cubePositions = CUBE_POSITIONS.map(p => ({ x: p.x, y: p.y, z: p.z }));

  // Reset qpos + ctrl to home pose
  if (simState.initialQpos && model && data) {
    for (let i = 0; i < simState.initialQpos.length; i++) {
      data.qpos[i] = simState.initialQpos[i];
    }
    for (let i = 0; i < HOME_POS.length; i++) data.ctrl[i] = HOME_POS[i];
    for (let i = 0; i < model.nv; i++) data.qvel[i] = 0;
    mujoco.mj_forward(model, data);
  }
  resetSmoothTarget();
  setPhase('IDLE', 'Scene reset.');
});

speedSlider.addEventListener('input', () => {
  simState.speed = parseFloat(speedSlider.value);
  speedVal.textContent = simState.speed + '×';
});

// ── Init sequence ─────────────────────────────────────────────────────
async function init() {
  setPhase('LOADING', 'Initializing...');

  // Step 1: Load WASM
  stepActive('step-wasm');
  let mj;
  try {
    mj = await loadMuJoCo();
    mujoco = mj;
    stepDone('step-wasm');
  } catch (err) {
    stepError('step-wasm', err.message);
    setPhase('ERROR', err.message);
    showError(err.message + ' — Check your internet connection or try again.');
    return;
  }

  // Step 2: Fetch model + VFS (both happen inside loadRobotModel)
  stepActive('step-model');
  let modelData;
  try {
    modelData = await loadRobotModel(mj);
    stepDone('step-model');
  } catch (err) {
    stepError('step-model', 'Model fetch failed: ' + err.message);
    setPhase('ERROR', 'Model load failed.');
    showError(err.message);
    return;
  }

  // Step 3: VFS built as part of model load
  stepActive('step-vfs');
  stepDone('step-vfs');

  // Step 4: Init physics
  stepActive('step-physics');
  try {
    model = modelData.model;
    data  = modelData.data;

    // Store initial qpos
    simState.initialQpos = [...data.qpos];

    // Set home pose for arm joints (7 arm + 2 finger = 9 actuated joints)
    const armQpos = HOME_POS;
    for (let i = 0; i < Math.min(armQpos.length, model.nq); i++) {
      data.qpos[i] = armQpos[i];
      data.ctrl[i] = armQpos[i]; // actuator targets must match or physics fights qpos
    }
    mujoco.mj_forward(model, data);

    // Find TCP site
    siteId = findSiteId(model, 'tcp');

    // Find gripper joints (finger_joint1, finger_joint2)
    const gj1 = findJointId(model, 'finger_joint1');
    const gj2 = findJointId(model, 'finger_joint2');
    if (gj1 >= 0) gripperJointIds.push(gj1);
    if (gj2 >= 0) gripperJointIds.push(gj2);

    // Find actuators that drive the gripper joints (joint transmission, trntype=0)
    for (let a = 0; a < model.nu; a++) {
      if (model.actuator_trntype[a] === 0) {
        const jid = model.actuator_trnid[a * 2];
        if (gripperJointIds.includes(jid)) gripperActuatorIds.push(a);
      }
    }

    // Find cube freejoint IDs (cube_joint_0 … cube_joint_N)
    for (let i = 0; i < CUBE_POSITIONS.length; i++) {
      cubeJointIds.push(findJointId(model, `cube_joint_${i}`));
    }

    // Build Three.js body groups
    bodyGroups = buildBodyGroups(mujoco, model);
    syncBodies(model, data, bodyGroups);

    stepDone('step-physics');
    stepDone('step-ready');

    // Hide loading overlay
    loadingOverlay.classList.add('hidden');

    // Enable controls
    btnScan.disabled  = false;
    btnAuto.disabled  = false;
    btnReset.disabled = false;

    setPhase('IDLE', 'Physics ready. Press Scan & Pick or Auto Demo.');

    // Start the loop
    startLoop();
  } catch (err) {
    stepError('step-physics', err.message);
    setPhase('ERROR', 'Physics init failed.');
    showError(err.message);
    return;
  }
}

// Free WASM heap objects when the page is torn down.
// MjModel and MjData are C++ objects on the WASM heap; dropping the JS
// reference does not call their destructors — .delete() must be explicit.
window.addEventListener('pagehide', () => {
  loopRunning = false;
  if (simState.frameId) cancelAnimationFrame(simState.frameId);
  if (data)  data.delete();
  if (model) model.delete();
});

init();
</script>
</body>
</html>
